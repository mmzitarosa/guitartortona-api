name: Build & Deploy to Staging

on:
  push:
    branches:
      - develop
      - hotfix

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-deployment:
    runs-on: [self-hosted, linux, k8s]
    outputs:
      should_deploy: ${{ steps.analyze.outputs.should_deploy }}
      type: ${{ steps.analyze.outputs.type }}
      branch: ${{ steps.analyze.outputs.branch }}
    steps:
      - name: Analyze commit message
        id: analyze
        run: |
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          BRANCH="${{ github.ref_name }}"
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          
          if [[ "$COMMIT_MSG" =~ ^RELEASE:.* ]]; then
            echo "type=RELEASE" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "✅ RELEASE commit detected - triggering deployment"
          elif [[ "$COMMIT_MSG" =~ ^MAJOR:.* ]]; then
            if [[ "$BRANCH" == "hotfix" ]]; then
              echo "❌ MAJOR commit not allowed on hotfix branch"
              exit 1
            fi
            echo "type=MAJOR" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "✅ MAJOR commit detected - triggering deployment"
          else
            echo "type=OTHER" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo ""
            echo "ℹ️  Regular commit - no deployment triggered"
            echo ""
            echo "💡 To trigger deployment, use:"
            echo "   git commit -m 'RELEASE: Your description'"
            echo "   git commit -m 'MAJOR: Your description' (only on develop)"
          fi

  build-and-deploy:
    needs: check-deployment
    if: needs.check-deployment.outputs.should_deploy == 'true'
    runs-on: [self-hosted, linux, k8s]
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if branch is behind main
        run: |
          git fetch origin main
          BEHIND=$(git rev-list --count HEAD..origin/main)
          
          if [ "$BEHIND" -gt 0 ]; then
            echo "❌ Branch is $BEHIND commits behind main"
            echo "Please merge main into your branch first"
            exit 1
          fi
          
          echo "✅ Branch is up to date with main"

      - name: Get latest production version
        id: prod_version
        run: |
          LATEST_PROD_TAG=$(git tag -l 'v*' | grep -v 'rc' | sort -V | tail -n1 || echo "v0.0.0")
          PROD_VERSION=${LATEST_PROD_TAG#v}
          
          echo "latest_prod_tag=$LATEST_PROD_TAG" >> $GITHUB_OUTPUT
          echo "prod_version=$PROD_VERSION" >> $GITHUB_OUTPUT
          echo "📦 Latest production version: $PROD_VERSION"

      - name: Calculate new version
        id: version
        run: |
          BRANCH="${{ needs.check-deployment.outputs.branch }}"
          TYPE="${{ needs.check-deployment.outputs.type }}"
          PROD_VERSION="${{ steps.prod_version.outputs.prod_version }}"
          
          IFS='.' read -r MAJOR MINOR PATCH <<< "$PROD_VERSION"
          
          if [[ "$TYPE" == "MAJOR" ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            RC=1
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-rc${RC}"
          
            echo "create_branches=true" >> $GITHUB_OUTPUT
            echo "prev_major=$((MAJOR - 1))" >> $GITHUB_OUTPUT
          
          elif [[ "$TYPE" == "RELEASE" ]]; then
            if [[ "$BRANCH" == "develop" ]]; then
              NEXT_MINOR=$((MINOR + 1))
              EXISTING_RC=$(git tag -l "v${MAJOR}.${NEXT_MINOR}.0-rc*" | sort -V | tail -n1)
          
              if [ -n "$EXISTING_RC" ]; then
                RC_NUM=${EXISTING_RC##*-rc}
                RC=$((RC_NUM + 1))
                NEW_VERSION="${MAJOR}.${NEXT_MINOR}.0-rc${RC}"
              else
                MINOR=$NEXT_MINOR
                PATCH=0
                RC=1
                NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-rc${RC}"
              fi
          
            elif [[ "$BRANCH" == "hotfix" ]]; then
              NEXT_PATCH=$((PATCH + 1))
              EXISTING_RC=$(git tag -l "v${MAJOR}.${MINOR}.${NEXT_PATCH}-rc*" | sort -V | tail -n1)
          
              if [ -n "$EXISTING_RC" ]; then
                RC_NUM=${EXISTING_RC##*-rc}
                RC=$((RC_NUM + 1))
                NEW_VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-rc${RC}"
              else
                PATCH=$NEXT_PATCH
                RC=1
                NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-rc${RC}"
              fi
            fi
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          
          echo "🏷️  New version: $NEW_VERSION"

      - name: Check if tag already exists
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "❌ Tag $TAG already exists!"
            exit 1
          fi
          
          echo "✅ Tag $TAG is available"

      - name: Set up Amazon Corretto 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'corretto'
          cache: maven

      - name: Update Maven version
        run: |
          ./mvnw versions:set -DnewVersion=${{ steps.version.outputs.version }}
          ./mvnw versions:commit

      - name: Build with Maven
        run: |
          ./mvnw clean package -DskipTests
          echo "✅ Maven build completed"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          IMAGE=$(echo "$IMAGE" | tr '[:upper:]' '[:lower:]')
          
          docker build -t ${IMAGE}:${VERSION} .
          docker tag ${IMAGE}:${VERSION} ${IMAGE}:staging
          
          docker push ${IMAGE}:${VERSION}
          docker push ${IMAGE}:staging
          
          echo "✅ Image pushed: ${IMAGE}:${VERSION}"
          echo "✅ Image pushed: ${IMAGE}:staging"
          echo "image_full=${IMAGE}" >> $GITHUB_ENV

      - name: Create Git tag
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          BRANCH="${{ needs.check-deployment.outputs.branch }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "$TAG" -m "Release $VERSION to staging from $BRANCH"
          git push origin "$TAG"
          
          echo "✅ Tag created: $TAG"

      - name: Checkout deploy repository
        uses: actions/checkout@v4
        with:
          repository: mmzitarosa/guitartortona-api-deploy
          ref: staging
          token: ${{ secrets.DEPLOY_TOKEN }}
          path: deploy-repo

      - name: Update deployment image
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IMAGE="${{ env.image_full }}"
          
          cd deploy-repo
          
          # Verifica che deployment.yaml esista nella root
          if [ ! -f "deployment.yaml" ]; then
            echo "❌ ERROR: deployment.yaml not found in root!"
            ls -la
            exit 1
          fi
          
          # Aggiorna immagine in deployment.yaml
          sed -i "s|image: ${IMAGE}:.*|image: ${IMAGE}:${VERSION}|" deployment.yaml
          
          echo "📝 Updated deployment.yaml:"
          grep "image:" deployment.yaml

      - name: Commit and push to deploy repo
        run: |
          cd deploy-repo
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add deployment.yaml
          
          if git diff --staged --quiet; then
            echo "ℹ️  No changes to commit"
          else
            git commit -m "chore(staging): update image to ${{ steps.version.outputs.version }} [skip ci]"
            git push origin staging
            echo "✅ Deployment config updated in guitartortona-api-deploy"
          fi

      - name: Wait for ArgoCD sync
        run: |
          echo ""
          echo "⏳ Waiting for ArgoCD to detect changes..."
          echo "   Repository: guitartortona-api-deploy"
          echo "   Branch: staging"
          echo "   Application: guitartortona-api-staging"
          echo "   Version: ${{ steps.version.outputs.version }}"
          echo ""
          sleep 45
          echo "✅ ArgoCD should be syncing now"
          echo ""
          echo "🔗 Check status:"
          echo "   ArgoCD: https://argocd.guitar.lab"
          echo "   Staging: https://api-staging.guitar.lab/actuator/health"

      - name: Deployment Summary
        run: |
          echo "## 🎉 Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | \`${{ steps.version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | \`${{ steps.version.outputs.tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ needs.check-deployment.outputs.branch }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | Staging |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image** | \`${{ env.image_full }}:${{ steps.version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔄 GitOps Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Docker image built and pushed" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Deployment config updated in \`guitartortona-api-deploy\`" >> $GITHUB_STEP_SUMMARY
          echo "- 🔄 ArgoCD will sync automatically (~30 seconds)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Check deployment:**" >> $GITHUB_STEP_SUMMARY
          echo "- [ArgoCD UI](https://argocd.guitar.lab)" >> $GITHUB_STEP_SUMMARY
          echo "- [Staging API](https://api-staging.guitar.lab/actuator/health)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🚀 Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "When staging tests pass, promote to production:" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to [Promote to Production workflow](https://github.com/${{ github.repository }}/actions/workflows/promote-production.yml)" >> $GITHUB_STEP_SUMMARY
          echo "2. Click 'Run workflow'" >> $GITHUB_STEP_SUMMARY
          echo "3. Enter version: \`${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
