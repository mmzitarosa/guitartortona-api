name: Promote to Production

on:
  workflow_dispatch:
    inputs:
      staging_version:
        description: 'Staging version to promote (e.g., 1.3.0-rc3)'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      prod_version: ${{ steps.version.outputs.prod_version }}
      source_branch: ${{ steps.branch.outputs.source_branch }}
      tag_commit: ${{ steps.branch.outputs.tag_commit }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate version format
        id: version
        run: |
          VERSION="${{ github.event.inputs.staging_version }}"
          
          if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+-rc[0-9]+$ ]]; then
            echo "‚ùå Error: Invalid version format. Must be X.Y.Z-rcN"
            exit 1
          fi
          
          PROD_VERSION=${VERSION%-rc*}
          echo "prod_version=$PROD_VERSION" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Staging version: $VERSION"
          echo "‚úÖ Production version: $PROD_VERSION"

      - name: Verify tag exists
        run: |
          VERSION="${{ github.event.inputs.staging_version }}"
          
          if ! git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "‚ùå Error: Tag v${VERSION} does not exist"
            exit 1
          fi
          
          echo "‚úÖ Tag v${VERSION} exists"

      - name: Verify Docker image exists
        run: |
          VERSION="${{ github.event.inputs.staging_version }}"
          
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          if ! docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}; then
            echo "‚ùå Error: Docker image ${VERSION} does not exist in registry"
            exit 1
          fi
          
          echo "‚úÖ Docker image ${VERSION} exists"

      - name: Determine source branch
        id: branch
        run: |
          VERSION="${{ github.event.inputs.staging_version }}"
          
          TAG_COMMIT=$(git rev-list -n 1 "v${VERSION}")
          echo "tag_commit=$TAG_COMMIT" >> $GITHUB_OUTPUT
          
          if git branch -r --contains $TAG_COMMIT | grep -q "origin/hotfix"; then
            SOURCE_BRANCH="hotfix"
          else
            SOURCE_BRANCH="develop"
          fi
          
          echo "source_branch=$SOURCE_BRANCH" >> $GITHUB_OUTPUT
          echo "‚úÖ Source branch: $SOURCE_BRANCH"
          echo "‚úÖ Tag commit: $TAG_COMMIT"

  deploy-production:
    needs: validate
    runs-on: [self-hosted, linux, k8s]
    steps:
      - name: Retag Docker image for production
        run: |
          STAGING_VERSION="${{ github.event.inputs.staging_version }}"
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          
          STAGING_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${STAGING_VERSION}
          PROD_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${PROD_VERSION}
          LATEST_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
          
          docker pull $STAGING_IMAGE
          docker tag $STAGING_IMAGE $PROD_IMAGE
          docker tag $STAGING_IMAGE $LATEST_IMAGE
          
          docker push $PROD_IMAGE
          docker push $LATEST_IMAGE
          
          echo "‚úÖ Retagged images:"
          echo "  - $PROD_IMAGE"
          echo "  - $LATEST_IMAGE"

      - name: Install kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi

      - name: Deploy to Production
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          
          kubectl set image deployment/guitartortona-api \
            guitartortona-api=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${PROD_VERSION} \
            -n default
          
          kubectl rollout status deployment/guitartortona-api -n default --timeout=300s
          
          echo "‚úÖ Deployed version $PROD_VERSION to production"

  create-release-pr:
    needs: [validate, deploy-production]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create release branch from tagged commit
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          TAG_COMMIT="${{ needs.validate.outputs.tag_commit }}"
          RELEASE_BRANCH="release/v${PROD_VERSION}"
          
          echo "Creating release branch from commit ${TAG_COMMIT}"
          
          # Create and checkout release branch from the specific tagged commit
          git checkout -b $RELEASE_BRANCH $TAG_COMMIT
          
          # Push release branch
          git push origin $RELEASE_BRANCH
          
          echo "‚úÖ Created release branch: $RELEASE_BRANCH from commit ${TAG_COMMIT}"

      - name: Create Pull Request from release branch to main
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          STAGING_VERSION="${{ github.event.inputs.staging_version }}"
          SOURCE_BRANCH="${{ needs.validate.outputs.source_branch }}"
          RELEASE_BRANCH="release/v${PROD_VERSION}"
          TAG_COMMIT="${{ needs.validate.outputs.tag_commit }}"
          
          # Create PR from release branch to main
          PR_URL=$(gh pr create \
            --base main \
            --head $RELEASE_BRANCH \
            --title "üöÄ Release v${PROD_VERSION}" \
            --body "## üöÄ Production Release v${PROD_VERSION}
          
          **Promoted from staging:** \`${STAGING_VERSION}\`  
          **Source branch:** \`${SOURCE_BRANCH}\`  
          **Tagged commit:** \`${TAG_COMMIT}\`
          
          ### ‚úÖ Deployment Status
          - **Production deployed:** ‚úÖ https://api.guitar.lab
          - **Docker images tagged:** ‚úÖ
            - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${PROD_VERSION}\`
            - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
          
          ### üì¶ Release Scope
          This PR contains **only** the code up to tag \`v${STAGING_VERSION}\`.  
          Any commits after this tag on ${SOURCE_BRANCH} are **not included**.
          
          ### ü§ñ Auto-Merge
          This PR will be automatically merged and the release branch deleted.
          
          ---
          *This is an automated release PR created by the promote-to-production workflow.*" \
            --label "release,automated")
          
          echo "‚úÖ Created PR: $PR_URL"
          
          # Extract PR number from URL
          PR_NUMBER=$(echo $PR_URL | grep -oP '\d+$')
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
          echo "‚úÖ PR Number: $PR_NUMBER"

      - name: Enable auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚è≥ Enabling auto-merge for PR #${PR_NUMBER}..."
          
          # Try merge commit first, fallback to squash if not allowed
          if gh pr merge ${PR_NUMBER} --auto --merge --delete-branch 2>/dev/null; then
            echo "‚úÖ Auto-merge enabled with merge commit strategy"
          elif gh pr merge ${PR_NUMBER} --auto --squash --delete-branch 2>/dev/null; then
            echo "‚úÖ Auto-merge enabled with squash strategy"
          elif gh pr merge ${PR_NUMBER} --auto --rebase --delete-branch 2>/dev/null; then
            echo "‚úÖ Auto-merge enabled with rebase strategy"
          else
            echo "‚ùå Failed to enable auto-merge. Trying without delete-branch..."
            if gh pr merge ${PR_NUMBER} --auto --merge; then
              echo "‚úÖ Auto-merge enabled (branch will not be auto-deleted)"
            elif gh pr merge ${PR_NUMBER} --auto --squash; then
              echo "‚úÖ Auto-merge enabled with squash (branch will not be auto-deleted)"
            else
              echo "‚ùå Could not enable auto-merge. Please check repository settings:"
              echo "   - Settings ‚Üí Pull Requests ‚Üí Allow auto-merge"
              echo "   - Settings ‚Üí Pull Requests ‚Üí Allow merge commits (or squash/rebase)"
              exit 1
            fi
          fi
          
          echo "‚úÖ Release branch will be deleted after merge (if supported)"

      - name: Wait for PR merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚è≥ Waiting for PR #${PR_NUMBER} to be merged..."
          echo "PR URL: https://github.com/${{ github.repository }}/pull/${PR_NUMBER}"
          
          for i in {1..60}; do
            sleep 5
          
            STATE=$(gh pr view ${PR_NUMBER} --json state --jq .state 2>/dev/null || echo "UNKNOWN")
          
            if [ "$STATE" == "MERGED" ]; then
              echo ""
              echo "‚úÖ PR #${PR_NUMBER} merged successfully!"
              exit 0
            fi
          
            if [ "$STATE" == "CLOSED" ]; then
              echo ""
              echo "‚ùå PR was closed without merging!"
              exit 1
            fi
          
            if [ "$STATE" == "UNKNOWN" ]; then
              echo "  Check $i/60: Unable to get PR state, retrying..."
            else
              echo "  Check $i/60: PR state is $STATE, waiting for merge..."
            fi
          done
          
          echo ""
          echo "‚ö†Ô∏è  PR not merged after 5 minutes"
          echo "Check manually: https://github.com/${{ github.repository }}/pull/${PR_NUMBER}"
          exit 1

  create-production-tag:
    needs: [validate, create-release-pr]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Create production tag on main
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          STAGING_VERSION="${{ github.event.inputs.staging_version }}"
          SOURCE_BRANCH="${{ needs.validate.outputs.source_branch }}"
          
          # Tag the current HEAD of main (which now includes the merged PR)
          git tag -a "v${PROD_VERSION}" -m "Production Release v${PROD_VERSION}

          üöÄ Promoted from staging: v${STAGING_VERSION}
          üì¶ Source branch: ${SOURCE_BRANCH}
          
          üåê Production: https://api.guitar.lab
          üê≥ Docker Images:
             - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${PROD_VERSION}
             - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          
          git push origin "v${PROD_VERSION}"
          
          echo "‚úÖ Created production tag: v${PROD_VERSION} on main"

  sync-branches:
    needs: [validate, create-production-tag]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Sync develop with main
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          
          echo "üì• Fetching develop branch..."
          git fetch origin develop:develop
          
          echo "üîÑ Syncing develop with main..."
          git checkout develop
          git merge origin/main --no-edit -m "Sync develop with production v${PROD_VERSION}"
          git push origin develop
          
          echo "‚úÖ Synced develop with main (production v${PROD_VERSION})"

      - name: Sync hotfix with main
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          
          echo "üì• Fetching hotfix branch..."
          git fetch origin hotfix:hotfix
          
          echo "üîÑ Syncing hotfix with main..."
          git checkout hotfix
          git merge origin/main --no-edit -m "Sync hotfix with production v${PROD_VERSION}"
          git push origin hotfix
          
          echo "‚úÖ Synced hotfix with main (production v${PROD_VERSION})"

  create-github-release:
    needs: [validate, sync-branches]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          PROD_VERSION="${{ needs.validate.outputs.prod_version }}"
          STAGING_VERSION="${{ github.event.inputs.staging_version }}"
          
          # Get commits between previous production tag and current
          PREV_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | grep -v "rc" | head -n 2 | tail -n 1)
          
          if [ -n "$PREV_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s (%h)" ${PREV_TAG}..v${PROD_VERSION} 2>/dev/null || echo "No previous release found")
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)" v${PROD_VERSION} 2>/dev/null || echo "Initial release")
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.validate.outputs.prod_version }}
          name: Release v${{ needs.validate.outputs.prod_version }}
          body: |
            ## üöÄ Production Release v${{ needs.validate.outputs.prod_version }}
            
            **Promoted from staging:** `${{ github.event.inputs.staging_version }}`  
            **Source branch:** `${{ needs.validate.outputs.source_branch }}`
            
            ### üåê Deployment
            - **Production:** https://api.guitar.lab
            - **Staging:** https://api-staging.guitar.lab
            
            ### üì¶ Docker Images
            ```
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.prod_version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ```
            
            ### üìù Changes
            ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}